buffer busy waits等待事件的原因：hot block 
Buffer Pin锁的相关等待事件是buffer busy waits
读不阻塞写，而写阻塞读。
造成buffer busy waits的元凶只能是DML语句！
例子：大批量并发插入导致buffer busy waits

当一个会话需要访问一个数据块，而这个数据块正在被另外一个用户从磁盘读取至内存中或者这个数据块正在被另一个会话修改，当前的会话就需要等待，
，此时会产生buffer busy waits。


************************************************************************************************************************************************
在SGA中读取或修改缓冲区的会话必须首先获取cache buffers chains锁存器，并且遍历这个缓冲区链，直到他发现必需的缓冲区头。然后，他必须以共享模式或独占模式获取
一个缓冲区锁或缓冲区头上的pin，这取决于他计划的操作。一旦缓冲区头被钉住，会话就释放cache buffers chains锁存器，并在缓冲区自身上执行计划的操作。如果无法获
取一个pin，会话就在buffer busy waits等待事件上等待。这种等待时间不会应用于在会话的私有PGA中执行的读取或写入操作。

　　块可能被其它的session读到缓冲区，所以session必须等待块的读入结束。
　　session可能有与等待的session查询不协调的缓冲块。

出现了hot block，所谓hot block指的是同时有若干个session，同时对一个block进行操作，导致此block比较忙；
导致block比较忙的原因是：oracle数据库的数据存放的最小单位就是block，数据每次读取数据的时候只能以block为单位；
如果有多条记录存放在一个block上的话，那么导致多个session访问同一个block的可能性就越大；
解决hot block的方法有：
1、出现此情况通常可能通过几种方式调整：增大data  buffer；
2、增加freelist，减小pctused；怎样的目的是将一个block上可以使用的空间减少，这样的话：一个block上的数据存放的较少，可以提高应用的访问并发率，减少hot block的产生；
3、增加回滚段数目，增大initrans，考虑使用LMT, 确认是不是由于热点块造成(如果是可以用反转索引,或者用更小块大小)；
3、可以建立block较小的表空间，见热点对象移动到此表空间上去；
4、优化应用，优化索引，提高索引的命中率；

◎ Oracle会话正在等待钉住一个缓冲区。必须在读取或修改缓冲区前将它钉住。在任何时刻只有一个进程可以钉住一个缓冲区。
◎ buffer busy waits表明读/读、读/写、写/写争用。
◎ 采取的适当措施取决于P3参数中的原因码。
    
A、如果等待处于字段头部，应增加自由列表（freelist）的组数，或者增加pctused到pctfree之间的距离。
B、如果等待处于回退段（undo）头部块，可以通过增加回滚段(rollback segment)来解决缓冲区的问题；
C、如果等待处于回退段（undo）非头部块上，就需要降低驱动一致读取的表中的数据密度,或者增大DB_CACHE_SIZE；
D、如果等待处于数据块，可以将数据移到另一数据块以避开这个"热"数据块、增加表中的自由列表或使用LMT表空间；
E、如果等待处于索引块，应该重建索引、分割索引或使用反向键索引。
************************************************************************************************************************************************

表数据块： 
分区表
将每个数据块存放记录的数量减到最少
alter table minimize records_per_block.


索引数据块：
反向索引


索引根数据块：
索引分区


redo：放在更快的磁盘上。
